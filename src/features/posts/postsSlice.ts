import {createSlice, PayloadAction} from "@reduxjs/toolkit";
import {createAppAsyncThunk} from "common/utils/createAppAsyncThunk";
import {postsAPI} from "features/posts/postsAPI";

export type CommentsType = {
    "postId": 1,
    "id": 1,
    "name": string,
    "email": string
    "body": string
}

export type PostsState = {
    posts: PostType[],
    status: string
    commonLength:number
}

export type PostType = {
    userId: number,
    id: number,
    title: string
    body: string,
    userName:string,
    comments:CommentsType[],
}

const initialState: PostsState = {
    posts: [],
    status: 'idle',
    commonLength:0
};

export const postsSlice = createSlice({
    name: 'posts',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        // increment: (state) => {
        //     // Redux Toolkit allows us to write "mutating" logic in reducers. It
        //     // doesn't actually mutate the state because it uses the Immer library,
        //     // which detects changes to a "draft state" and produces a brand new
        //     // immutable state based off those changes
        //     state.value += 1;
        // },
        // decrement: (state) => {
        //     state.value -= 1;
        // },
        // // Use the PayloadAction type to declare the contents of `action.payload`
        // incrementByAmount: (state, action: PayloadAction<number>) => {
        //     state.value += action.payload;
        // },
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder
            .addCase(fetchPosts.fulfilled, (state,action) => {
                state.posts = action.payload.posts.map((el:PostType)=>({...el,userName:'',comments:[]}))
                console.log(state.posts)
                state.commonLength = action.payload.commonLength;
            })
            .addCase(getUserName.fulfilled, (state,action) => {
                const post = state.posts.find(el=> el.id === action.payload.id)
                if(post){
                    post.userName = action.payload.name
                }
            })
            .addCase(getComments.fulfilled, (state,action) => {
                const post = state.posts.find(el=> el.id === action.payload.postId)
                if(post){
                    post.comments = action.payload.comments
                }
            })
    },
});

type fetchPostsArgType = {
    page:number,
    limit:number
}

const fetchPosts = createAppAsyncThunk('posts/fetchPosts', async ( arg:fetchPostsArgType,thunkAPI) => {
    const {dispatch, rejectWithValue} = thunkAPI
    try {
        const allPosts = await postsAPI.getAllPosts()
        const commonLength = allPosts.data.length
        const res = await postsAPI.getPosts(arg.page,arg.limit)
        const posts = res.data
        return {posts,commonLength}
    } catch (e: any) {
        return rejectWithValue(e.message)
    }
})

type fetchCommentsPropsType = {
    postId:number
}

const getComments = createAppAsyncThunk('posts/fetchComments', async ( arg:fetchCommentsPropsType,thunkAPI) => {
    const {dispatch, rejectWithValue} = thunkAPI
    try {
        const res = await postsAPI.getComments(arg.postId)
        const comments = res.data
        return {comments,postId:arg.postId}
    } catch (e: any) {
        return rejectWithValue(e.message)
    }
})

type getUserNameArgType = {
    id:number,
    userId:number
}

const getUserName = createAppAsyncThunk('posts/gerUserName', async ( arg:getUserNameArgType,thunkAPI) => {
    const {dispatch, rejectWithValue} = thunkAPI
    try {
        const res = await postsAPI.getUserName(arg.userId)
        return {name:res.data.name,userId:arg.userId,id:arg.id}
    } catch (e: any) {
        return rejectWithValue(e.message)
    }
})




export const postsThunks = {fetchPosts,getUserName,getComments}
export const postsReducer = postsSlice.reducer